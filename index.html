<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced 3D Biking Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #titleScreen { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(0, 0, 0, 0.8); 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            color: white; 
            font-family: Arial; 
            font-size: 24px; 
        }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: white; 
            font-family: Arial; 
            display: none; 
        }
        #startButton {
            padding: 10px 20px; 
            background-color: #007BFF; 
            color: white; 
            border: none; 
            cursor: pointer; 
            font-size: 24px; 
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="titleScreen">
        <div>Advanced 3D Biking Game</div>
        <button id="startButton">Start Game</button>
    </div>
    <div id="info">Use WASD to move, Space to jump</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/GLTFLoader.js"></script>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);  // Sky blue background
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Improved Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Bike model
        let bike = new THREE.Group();
        const bikeBody = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 2),
            new THREE.MeshPhongMaterial({ color: 0x0000ff })
        );
        bike.add(bikeBody);
        bike.position.set(0, 1, 0);  // Raise the bike above the ground
        scene.add(bike);

        // Function to respawn bike
        function respawnBike() {
            bike.position.set(0, 1, 0);
            bike.rotation.set(0, 0, 0);
        }

        // Function to check collisions
        function checkCollisions() {
            // Simple collision detection with the ground
            if (bike.position.y < 0) {
                respawnBike();
            }
        }

        // Chunk system
        const chunkSize = 100;
        const chunksInView = 3;
        const chunks = new Map();

        function generateChunk(x, z) {
            const chunk = new THREE.Group();
            
            // Generate terrain
            const terrainGeometry = new THREE.PlaneGeometry(chunkSize, chunkSize, 20, 20);
            const terrainMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            chunk.add(terrain);

            // Add some random trees
            for (let i = 0; i < 10; i++) {
                const treeGeometry = new THREE.ConeGeometry(2, 5, 8);
                const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x006400 });
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                tree.position.set(
                    Math.random() * chunkSize - chunkSize / 2,
                    2.5,
                    Math.random() * chunkSize - chunkSize / 2
                );
                chunk.add(tree);
            }

            chunk.position.set(x * chunkSize, 0, z * chunkSize);
            return chunk;
        }

        function updateChunks() {
            const playerChunkX = Math.floor(bike.position.x / chunkSize);
            const playerChunkZ = Math.floor(bike.position.z / chunkSize);

            for (let x = -chunksInView; x <= chunksInView; x++) {
                for (let z = -chunksInView; z <= chunksInView; z++) {
                    const chunkX = playerChunkX + x;
                    const chunkZ = playerChunkZ + z;
                    const chunkKey = `${chunkX},${chunkZ}`;

                    if (!chunks.has(chunkKey)) {
                        const chunk = generateChunk(chunkX, chunkZ);
                        chunks.set(chunkKey, chunk);
                        scene.add(chunk);
                    }
                }
            }

            // Remove far chunks
            for (const [key, chunk] of chunks) {
                const [x, z] = key.split(',').map(Number);
                if (Math.abs(x - playerChunkX) > chunksInView || Math.abs(z - playerChunkZ) > chunksInView) {
                    scene.remove(chunk);
                    chunks.delete(key);
                }
            }
        }

        // Set up initial camera position
        camera.position.set(0, 5, 10);
        camera.lookAt(bike.position);

        // Bike controls
        const bikeSpeed = 0.5;
        const turnSpeed = 0.05;
        const keys = {};

        document.addEventListener('keydown', (event) => keys[event.code] = true);
        document.addEventListener('keyup', (event) => keys[event.code] = false);

        function moveBike() {
            // Calculate direction based on camera rotation
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);

            const moveDirection = new THREE.Vector3();

            // Adjust movement direction relative to camera
            if (keys['KeyW']) {
                moveDirection.copy(cameraDirection);
                moveDirection.y = 0; // Keep movement horizontal
                bike.position.add(moveDirection.normalize().multiplyScalar(bikeSpeed));
            }
            if (keys['KeyS']) {
                moveDirection.copy(cameraDirection);
                moveDirection.y = 0;
                bike.position.add(moveDirection.normalize().multiplyScalar(-bikeSpeed));
            }
            if (keys['KeyA']) bike.rotation.y += turnSpeed;
            if (keys['KeyD']) bike.rotation.y -= turnSpeed;
            if (keys['Space'] && bike.position.y <= 1) bike.position.y += 0.2;
            else if (bike.position.y > 1) bike.position.y -= 0.1;  // Gravity
        }

        // Multiplayer setup (commented out for now)
        /*
        let socket;
        try {
            socket = io('http://your-backend-server.com');

            socket.on('connect', () => {
                console.log('Connected to server');
            });

            socket.on('updatePlayers', (players) => {
                // Update other players' positions
            });

            function updateServer() {
                socket.emit('updatePosition', {
                    x: bike.position.x,
                    y: bike.position.y,
                    z: bike.position.z,
                    rotationY: bike.rotation.y
                });
            }
        } catch (error) {
            console.error('Failed to connect to the server:', error);
        }
        */

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            moveBike();
            updateChunks();
            checkCollisions();
            //if (socket && socket.connected) updateServer();

            // Update camera position to follow the bike
            camera.position.x = bike.position.x - 10 * Math.sin(bike.rotation.y);
            camera.position.y = bike.position.y + 5;
            camera.position.z = bike.position.z - 10 * Math.cos(bike.rotation.y);
            camera.lookAt(bike.position);

            renderer.render(scene, camera);
        }

        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            animate();
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
